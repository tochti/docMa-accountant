package accountantService

import (
	"encoding/csv"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"

	"github.com/gin-gonic/gin"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

func LoadAccFiles(c *gin.Context) {
	session, err := mgo.Dial(GetSettings("BEBBER_DB_SERVER"))
	if err != nil {
		errMsg := "Db error - " + err.Error()
		c.JSON(http.StatusOK, ErrorResponse{"fail", errMsg})
		return
	}
	defer session.Close()

	collection := session.DB(GetSettings("BEBBER_DB_NAME")).C(DbFileCollection)

	accData := []AccData{}
	err = ReadAccFile(GetSettings("BEBBER_ACC_FILE"), &accData)
	if err != nil {
		c.JSON(http.StatusOK, ErrorResponse{"fail", err.Error()})
		return
	}

	validCSV := false
	r, err := c.Get("validCSV")
	if err == nil {
		validCSV = r.(bool)
	}
	accFiles, err := JoinAccFile(accData, collection, validCSV)
	if err != nil {
		c.JSON(http.StatusOK, ErrorResponse{"fail", err.Error()})
		return
	}

	res := LoadAccFilesResponse{
		Status:   "success",
		AccFiles: accFiles,
	}

	c.JSON(http.StatusOK, res)
}

func ReadAccFile(fName string, ad *[]AccData) error {
	f, err := os.Open(fName)
	if err != nil {
		return err
	}
	reader := csv.NewReader(f)
	reader.Comma = ';'
	reader.FieldsPerRecord = 13
	// Skip Headline
	reader.Read()
	for {
		r := AccData{}
		err := UnmarshalAccData(reader, &r)
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		} else {
			if (r.Belegdatum.IsZero() == true) &&
				(r.Buchungsdatum.IsZero() == true) &&
				(r.Belegnummernkreis == "") &&
				(r.Belegnummer == "") {
				continue
			}
			*ad = append(*ad, r)
		}
	}
	return nil
}

func UnmarshalAccData(reader *csv.Reader, data *AccData) error {
	s, err := reader.Read()
	if err != nil {
		return err
	}

	if (s[0] == "") && (s[1] == "") && (s[2] == "") && (s[3] == "") {
		data.Belegdatum = GetZeroDate()
		data.Buchungsdatum = GetZeroDate()
		data.Belegnummernkreis = ""
		data.Belegnummer = ""
	} else {
		/*
		   Sind die ersten vier Felder leer ist der Eintrag ein Teil einer
		   Rechnung data.h die in diesem if-Block zugewiesenen Felder können nicht
		   zugewiesen werden, dies ist jedoch kein Fehler alle
		   restliche vorhanden Daten werden zugewisen was damit passiert
		   muss die aufrufende Funktion bestimmen.
		*/
		date, err := ParseGermanDate(s[0], ".")
		if err != nil {
			return errors.New("Cannot create Belegdatum")
		}
		data.Belegdatum = date

		date, err = ParseGermanDate(s[1], ".")
		if err != nil {
			return errors.New("Cannot create Buchungsdatum")
		}
		data.Buchungsdatum = date

		data.Belegnummernkreis = s[2]
		data.Belegnummer = s[3]
	}

	data.Buchungstext = s[4]
	fl, err := ParseFloatComma(s[5])
	if err != nil {
		return errors.New("Buchungstext have to be a float - " + err.Error())
	}
	data.Buchungsbetrag = fl

	in, err := ParseAccInt(s[6])
	if err != nil {
		return errors.New("Sollkonto have to be a integer - " + err.Error())
	}
	data.Sollkonto = in

	in, err = ParseAccInt(s[7])
	if err != nil {
		return errors.New("Habenkonto have to be a integer - " + err.Error())
	}
	data.Habenkonto = in

	in, err = strconv.ParseInt(s[8], 10, 32)
	if err != nil {
		return errors.New("Steuerschlüssel have to be a integer - " + err.Error())
	}
	data.Steuerschlüssel = in
	data.Kostenstelle1 = s[9]
	data.Kostenstelle2 = s[10]

	fl, err = ParseFloatComma(s[11])
	if err != nil {
		return errors.New("Buchungstext have to be a float - " + err.Error())
	}
	data.BuchungsbetragEuro = fl
	data.Waehrung = s[12]

	return nil
}

func JoinAccFile(data []AccData, collection *mgo.Collection, validCSV bool) ([]AccFile, error) {

	fItems := []bson.M{}
	var tmp bson.M
	for i := range data {
		// Create mgo find query for each account dataset
		hKonto := strconv.FormatInt(data[i].Habenkonto, 10)
		sKonto := strconv.FormatInt(data[i].Sollkonto, 10)
		no := data[i].Belegnummernkreis + data[i].Belegnummer

		tmp = bson.M{"$or": []bson.M{

			// Find invoices
			bson.M{
				"valuetags": bson.M{
					"$elemMatch": bson.M{
						"tag":   "Belegnummer",
						"value": no,
					},
				},
			},

			// Find statments
			bson.M{"$and": []bson.M{

				bson.M{
					"rangetags": bson.M{
						"$elemMatch": bson.M{
							"tag":   "Belegzeitraum",
							"start": bson.M{"$lte": data[i].Belegdatum},
							"end":   bson.M{"$gte": data[i].Belegdatum},
						},
					},
				},

				bson.M{
					"valuetags": bson.M{
						"$elemMatch": bson.M{
							"tag": "Kontonummer",
							"value": bson.M{"$in": []string{
								hKonto,
								sKonto,
							}},
						},
					},
				},
			}},
		}}

		fItems = append(fItems, tmp)
	}

	tmpResult := FileDocsNew([]FileDoc{})
	filter := bson.M{"$or": fItems}
	iter := collection.Find(filter).Iter()
	err := iter.All(&tmpResult.List)
	if err != nil {
		return nil, err
	}

	result := []AccFile{}
	for i, r := range data {
		q := FileDoc{
			ValueTags: []ValueTag{
				ValueTag{"Belegnummer", r.Belegnummernkreis + r.Belegnummer},
			},
		}
		docs := tmpResult.FindFile(q)

		if len(docs.List) == 0 {
			continue
		} else if len(docs.List) > 1 {
			docsJson, _ := json.Marshal(docs.List)
			errMsg := string(docsJson) + " have the same Belegnummer " + r.Belegnummer
			return nil, errors.New(errMsg)
		} else if len(docs.List) == 1 {
			tmp := AccFile{data[i], docs.List[0]}
			result = append(result, tmp)
			data[i] = AccData{}
		}
	}
	for i, r := range data {
		docs := tmpResult.FindStat(r.Belegdatum, r.Sollkonto, r.Habenkonto)
		if len(docs.List) == 0 {
			continue
		}
		tmp := AccFile{data[i], docs.List[0]}
		result = append(result, tmp)
		data[i] = AccData{}
	}

	if validCSV == true {
		fmt.Println("Prüfe Buchhaltungsdaten")
		valid := true
		for _, r := range data {
			if r.Empty() == false {
				date := DateToString(r.Belegdatum)
				fmt.Println("\t E: ", date, r.Belegnummernkreis,
					r.Belegnummer, r.Buchungstext, r.Sollkonto,
					r.Habenkonto, r.Buchungsbetrag)
				valid = false
			}
		}
		if valid {
			fmt.Println("\tAlles OK!")
		}
	}

	return result, nil
}

func (ad AccData) Empty() bool {
	if (ad.Belegdatum.IsZero()) &&
		(ad.Buchungsdatum.IsZero()) &&
		(ad.Belegnummernkreis == "") &&
		(ad.Belegnummer == "") &&
		(ad.Buchungstext == "") &&
		(ad.Buchungsbetrag == 0) &&
		(ad.Sollkonto == 0) &&
		(ad.Habenkonto == 0) &&
		(ad.Steuerschlüssel == 0) &&
		(ad.Kostenstelle1 == "") &&
		(ad.Kostenstelle2 == "") &&
		(ad.BuchungsbetragEuro == 0.0) &&
		(ad.Waehrung == "") {
		return true
	} else {
		return false
	}
}
